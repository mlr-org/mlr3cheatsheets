\documentclass{beamer}

\usepackage[orientation=landscape,size=a0,scale=1.4,debug]{beamerposter}
\mode<presentation>{\usetheme{mlr}}

\usepackage[sfdefault]{roboto}
\usepackage{roboto-mono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} % UTF-8
\usepackage[english]{babel} % Language
\usepackage{hyperref} % Hyperlinks
\usepackage{ragged2e} % Text position
\usepackage[export]{adjustbox} % Image position
\usepackage[most]{tcolorbox} % Code boxes
\usepackage{multido}

\hypersetup{
    hyperfootnotes=false,
    colorlinks=true,
	linktocpage=true,
	pdfauthor={mlr-org team},
    %linkcolor=[RGB]{3,99,142}, % mlr blue
    urlcolor=[RGB]{231,138,69}
}

\title{Machine learning with mlr3 :\,: CHEAT SHEET} % Package title in header, \, adds thin space between ::

\newlength{\columnheight} % Adjust depending on header height
\setlength{\columnheight}{84cm}

\newtcolorbox{codebox}{%
	sharp corners,
	leftrule=0pt,
	rightrule=0pt,
	toprule=0pt,
	bottomrule=0pt,
	fontupper=\robotomono\small,
	hbox}

\newtcolorbox{codeboxmultiline}[1][]{%
	sharp corners,
	leftrule=0pt,
	rightrule=0pt,
	toprule=0pt,
	bottomrule=0pt,
	fontupper=\robotomono\small,
	#1}

\newtcolorbox{codeboxexample}{%
	sharp corners,
	leftrule=0pt,
	rightrule=0pt,
	toprule=0pt,
	bottomrule=0pt,
	fontupper=\robotomono\small,
	width=27cm,
	adjusted title=Example,
	fonttitle = \bfseries\Large,
	top = 0.5em}

\newtcolorbox{codeboxinline}{%
	sharp corners,
	leftrule=0pt,
	rightrule=0pt,
	toprule=0pt,
	bottomrule=0pt,
	hbox,
	nobeforeafter,
	fontupper=\robotomono\small,
	tcbox raise base}

\newcommand{\codeinline}[1]{\begin{codeboxinline}#1\end{codeboxinline}}
\newcommand{\sectionheading}[1]{{\color{mlrblue}\large\raggedright\textbf{#1}}\vspace{1em}}
\newcommand{\monospace}[1]{\multido{}{#1}{\space}}

\begin{document}
\begin{frame}[fragile]{}
	\begin{columns}
		\begin{column}{.245\textwidth}
			\begin{beamercolorbox}[center]{postercolumn}
				\begin{minipage}{.98\textwidth}
					\parbox[t][\columnheight]{\textwidth}{
						\begin{myblock}{Intro}
							The \textbf{mlr3} package builds on R6 classes and provides the essential building
							blocks of a machine learning workflow.
						\end{myblock}
						\begin{myblock}{mlr3 Dictionaries}
							Key-value store for sets of mlr objects. These are provided by mlr3:
							\begin{itemize}
								\item \codeinline{mlr\_tasks} - ML example tasks.
								\item \codeinline{mlr\_task\_generators} - Example generators.
								\item \codeinline{mlr\_learners} - ML algorithms.
								\item \codeinline{mlr\_measures} - Performance measures.
								\item \codeinline{mlr\_resamplings} - Resampling strategies.
							\end{itemize}
							\vspace{0.5em}
							These dictonaries can be extended by loading extension packages.
							For example, by loading the \textbf{mlr3learners} package, the \codeinline {mlr\_learners} dictionary is extended with more learners.
							\vspace{1em}
							\\
							Syntactic sugar functions retrieve objects from dictonaries, set hyperparameters and assign fields in one go e.g. \codeinline{lrn("classif.rpart", cp = 0.1)}.
							\\
							\begin{codebox}
								Dictionary\$\textbf{keys}(pattern = NULL)
							\end{codebox}
							Returns all keys which match \codeinline{pattern}.
							If \codeinline{NULL}, all keys are returned.
							\\
							\begin{codebox}
								Dictionary\$\textbf{get}(key, ...)
							\end{codebox}
							Retrieves object by \codeinline{key} and passes arguments "..." to the construction of the objects.
							\\
							\begin{codebox}
								Dictionary\$\textbf{mget}(keys, ...)
							\end{codebox}
							Retrieves objects by \codeinline{keys} and
							passes named arguments "..." to the construction of the objects.
							\\
							\begin{codebox}
								as.data.table(Dictionary)
							\end{codebox}
							Lists objects with metadata.
						\end{myblock}
						\vfill}
				\end{minipage}
			\end{beamercolorbox}
		\end{column}
		\begin{column}{.245\textwidth}
			\begin{beamercolorbox}[center]{postercolumn}
				\begin{minipage}{.98\textwidth}
					\parbox[t][\columnheight]{\textwidth}{
						\begin{myblock}{Class: Task}
							Stores data and metadata. \codeinline{backend} can be a \codeinline{data.table},
							\codeinline{target} points to y-column by name.
							\\
							\begin{codebox}
								task = \textbf{TaskRegr}\$new(backend, target)
							\end{codebox}
							\begin{codebox}
								task = \textbf{TaskClassif}\$new(backend, target)
							\end{codebox}
							Create task for regression or classification.
							\\
							\begin{codebox}
								task = tsk(.key)
							\end{codebox}
							Sugar to get example task from \codeinline{mlr\_tasks}:
							\\
							\begin{itemize}
								\item Twoclass: \codeinline{german\_credit}, \codeinline{pima}, \codeinline{sonar},
								      \codeinline{spam}
								\item Multiclass: \codeinline{iris}, \codeinline{wine}, \codeinline{zoo}
								\item Regression: \codeinline{boston\_housing}, \codeinline{mtcars}
							\end{itemize}
							\vspace{1em}
							Print the \codeinline{mlr\_tasks} dictionary for more.
							\vspace{0.5em}
							\begin{codebox}
								task\$\textbf{positive} = "<positive\_class>"
							\end{codebox}
							Set positive class for binary classification.
							\vspace{1em}
							\\
							\sectionheading{Column Roles}
							\\
							Column roles affect the behavior of the task for different operations.
							Set with
							\\
							\codeinline{task\$\textbf{col\_roles}\$<role> = "<column\_name>"}:
							\\
							\begin{itemize}
								\item \codeinline{feature} - Regular features.
								\item \codeinline{target} - Target variable.
								\item \codeinline{name} - Labels for plots.
								\item \codeinline{group} -  Groups for block resampling.
								\item \codeinline{stratum} - Stratification variables.
								\item \codeinline{weight} - Observation weights.
							\end{itemize}
							\vspace{1em}
							\sectionheading{Data Operations}
							\begin{codebox}
								task\$\textbf{select}(cols)
							\end{codebox}
							Subsets the task based on feature names.
							\\
							\begin{codebox}
								task\$\textbf{filter}(rows)
							\end{codebox}
							Subsets the task based on row ids.
							\\
							\begin{codebox}
								task\$\textbf{cbind}(data) / task\$\textbf{rbind}(data) 
							\end{codebox}
							Adds additional columns / rows.
							\\
							\begin{codebox}
								task\$\textbf{rename}(from, to)
							\end{codebox}
							Rename columns.
						\end{myblock}
						\vfill}
				\end{minipage}
			\end{beamercolorbox}
		\end{column}
		\begin{column}{.245\textwidth}
			\begin{beamercolorbox}[center]{postercolumn}
				\begin{minipage}{.98\textwidth}
					\parbox[t][\columnheight]{\textwidth}{
						\begin{myblock}{Class: Learner}
							Wraps learners from R with a unified interface.
							\\
							\begin{codebox}
								learner = \textbf{lrn}(.key, ...)
							\end{codebox}
							Get learner by \codeinline{.key} (from \codeinline{mlr\_learners})
							and construct the learner with specific hyperparameters and settings "..." in one go.
							\\
							\href{https://github.com/mlr-org/mlr3learners}{https://github.com/mlr-org/mlr3learners} (R package) and \href{https://github.com/mlr3learners}{https://github.com/mlr3learners} (GitHub organization) hold all available learners.
							\\
							\begin{codebox}
								learner\$\textbf{param\_set}
							\end{codebox}
							Returns description of hyperparameters.
							\\
							\begin{codebox}
								learner\$param\_set\$\textbf{values} = list(id = value)
							\end{codebox}
							Change the current hyperparameter values by assigning a named \codeinline{list(id = value)} to the \codeinline{\$values} field.
							This overwrites all previously set parameters.
							\\
							\begin{codebox}
								learner\$param\_set\$\textbf{values}\$<id> = <value>
							\end{codebox}
							Update a single hyperparameter.
							\vspace{1em}
							\\
							\begin{codebox}
								learner\$\textbf{predict\_type} = "<type>"
							\end{codebox}
							Changes/sets the output type of the prediction. For classification, \codeinline{"response"} means class labels, \codeinline{"prob"} means posterior probabilities.
							For regression, \codeinline{"response"} means numeric response,
							\codeinline{"se"} extracts the standard error.
							\vspace{1em}
							\begin{codeboxexample}
								{\scriptsize
									task = tsk("sonar")\\
									learner = lrn("classif.rpart")
									\vspace{1em}
									\\
									train\_set = sample(task\$nrow, 0.8 * task\$nrow)\\
									test\_set = setdiff(seq\_len(task\$nrow), train\_set)
									\vspace{1em}
									\\
									learner\$train(task, row\_ids = train\_set)
									\vspace{1em}
									\\
									prediction = learner\$predict(task, row\_ids = test\_set)\\
									prediction\$score()\\
									\#\# classif.ce\\
									\#\# \space 0.2619048}
							\end{codeboxexample}
						\end{myblock}
						\vfill}
				\end{minipage}
			\end{beamercolorbox}
		\end{column}
		\begin{column}{.245\textwidth}
			\begin{beamercolorbox}[center]{postercolumn}
				\begin{minipage}{.98\textwidth}
					\parbox[t][\columnheight]{\textwidth}{
						\begin{myblock}{Train \& Predict}
							\vspace{0.25em}
							\begin{codebox}
								learner\$\textbf{train}(task, row\_ids)
							\end{codebox}
							Train on (selected) observations.
							\\
							\begin{codebox}
								learner\$\textbf{model}
							\end{codebox}
							The resulting model is stored in the \codeinline{\$model}/ slot of the \codeinline{learner}.
							\\
							\vspace{1em} % Group Predict
							\begin{codebox}
								prediction = learner\$\textbf{predict}(task, row\_ids)
							\end{codebox}
							Predict on ( selected) observations.
							\\
							\begin{codeboxmultiline}[width=23cm]
								{\footnotesize prediction\\
									\#\# <PredictionClassif> for 42 observations:\\
									\#\# row\_id truth response\\
									\#\# \space\space\space\space\space 2
									\space\space\space\space R \space\space\space\space\space\space\space M\\
									\#\# \space\space\space\space\space 3
									\space\space\space\space R \space\space\space\space\space\space\space M\\
									\#\# \space\space\space\space\space 5
									\space\space\space\space R \space\space\space\space\space\space\space M\\
									\#\# - - -\\
									\#\# \space\space\space 198
									\space\space\space\space M \space\space\space\space\space\space\space M\\
									\#\# \space\space\space 200
									\space\space\space\space M \space\space\space\space\space\space\space M\\
									\#\# \space\space\space 207
									\space\space\space\space M \space\space\space\space\space\space\space M}
							\end{codeboxmultiline}
							\vspace{1em}
							\begin{codebox}
								prediction\$\textbf{data\$tab}
							\end{codebox}
							Returns predictions as \codeinline{data.table}.
						\end{myblock}
						\begin{myblock}{Measures \& Scoring}
							\begin{codebox}
								measure = \textbf{msr}(.key)
							\end{codebox}
							Get measure by \codeinline{.key} from \codeinline{mlr\_measures}:
							\begin{itemize}
								\item \codeinline{classif.ce} - Classification error.
								\item \codeinline{classif.auc} - AUROC.
								\item \codeinline{regr.rmse} - Root mean square error.
							\end{itemize}
							\vspace{1em}
							Print \codeinline{mlr\_measures} for all measures.
							\\
							\begin{codebox}
								prediction\$\textbf{score}(measures)
							\end{codebox}
							Calculate performance with one or more measures.
						\end{myblock}
						\vfill}
				\end{minipage}
			\end{beamercolorbox}
		\end{column}
	\end{columns}
\end{frame}
\begin{withoutheader}
	\begin{frame}[fragile]{}
		\begin{columns}
			\begin{column}{.245\textwidth}
				\begin{beamercolorbox}[center]{postercolumn}
					\begin{minipage}{.98\textwidth}
						\parbox[t][\columnheight]{\textwidth}{
							\begin{myblock}{Class: Resampling}
								Define partitioning of task into train and test sets.\\
								Creation: \codeinline{resampling = \textbf{rsmp}(.key, ...)}
								\\
								\begin{itemize}
									\item \codeinline{holdout}
									      (\codeinline{ratio})\\
									      Holdout-validation.
									\item \codeinline{cv}
									      (\codeinline{folds})\\
									      k-fold cross-validation.
									\item \codeinline{repeated\_cv}
									      (\codeinline{folds}, \codeinline{repeats})\\
									      Repeated k-fold cross-validation.
									\item \codeinline{subsampling}
									      (\codeinline{repeats}, \codeinline{ratio})\\
									      Repeated holdouts.
									\item \codeinline{bootstrap}
									      (\codeinline{repeats}, \codeinline{ratio})\\
									      Out-of-bag bootstrap.
									\item Custom splits \\
									      \begin{codeboxmultiline}[width=26cm]
										      resampling = rsmp("\textbf{custom}")\\
										      resampling\$instantiate(task,\\
										      \hspace*{1ex} train = list(c(1:10, 51:60, 101:110)),\\
										      \hspace*{1ex} test = list(c(11:20, 61:70, 111:120)))
									      \end{codeboxmultiline}
								\end{itemize}
								\vspace{1em}
								\begin{codebox}
									resampling\$\textbf{param\_set}
								\end{codebox}
								Returns a description of parameter settings.
								\\
								\begin{codebox}
									{\footnotesize resampling\$param\_set\$\textbf{values} = list(folds = 10)}
								\end{codebox}
								Sets folds to 10.
								\\
								\begin{codebox}
									task\$col\_roles\$\textbf{stratum} = "<column\_names>"
								\end{codebox}
								Sets stratification variables.
								\\
								\begin{codebox}
									task\$col\_roles\$\textbf{group} = "<column\_name>"
								\end{codebox}
								Sets group variable.
								\\
								\begin{codebox}
									resampling\$\textbf{instantiate}(task)
								\end{codebox}
								Perform splitting and define index sets.
							\end{myblock}
							\vfill}
					\end{minipage}
				\end{beamercolorbox}
			\end{column}
			\begin{column}{.245\textwidth}
				\begin{beamercolorbox}[center]{postercolumn}
					\begin{minipage}{.98\textwidth}
						\parbox[t][\columnheight]{\textwidth}{
							\begin{myblock}{Resample}
								Train-Predict-Score a learner on each train/test set.
								\\
								\begin{codebox}
									rr = \textbf{resample}(task, learner, resampling)
								\end{codebox}
								Returns a \codeinline{ResampleResult} container object.
								\\
								\begin{codebox}
									rr\$\textbf{score}(measures)
								\end{codebox}
								Returns a \codeinline{data.table} of scores on test sets.
								\\
								\begin{codebox}
									rr\$\textbf{aggregate}(measures)
								\end{codebox}
								Gets aggregated performance scores as vector.
								\\
								\begin{codebox}
									rr\$\textbf{filter}(iters)
								\end{codebox}
								Filters to specific iterations.
								\\
								\begin{codeboxexample}
									\tiny{
										task = tsk("pima")\\
										learner = lrn("classif.rpart", predict\_type = "prob")\\
										measure = msr("classif.ce")
										\vspace{1em}
										\\
										resampling = rsmp("cv", folds = 3L)\\
										resampling\$instantiate(task)
										\vspace{1em}
										\\
										rr = resample(task, learner, resampling)
										\vspace{1em}
										\\
										rr\$data\\
										\#\# ...\monospace{3}resampling iteration prediction\\
										\#\# ... <ResamplingCV>\monospace{9}1\monospace{5}<list>\\
										\#\# ... <ResamplingCV>\monospace{9}2\monospace{5}<list>\\
										\#\# ... <ResamplingCV>\monospace{9}3\monospace{5}<list>
										\vspace{1em}
										\\
										rr\$aggregate(measure)\\
										\#\# classif.ce\\
										\#\# \monospace{4}0.2643
										\vspace{1em}
										\\
										learners = lrns(c("classif.rpart", "classif.ranger"))\\
										tasks = tsks(c("sonar", "spam"))\\
										resampling = rsmp("cv", folds = 3L)
										\vspace{1em}
										\\
										design = benchmark\_grid(tasks, learners,resampling)
										\vspace{1em}
										\\
										bmr = benchmark(design)\\
										bmr\\
										\#\# <BenchmarkResult> of 12 rows with 4 resampling runs\\
										\#\# nr task\_id\monospace{5}learner\_id resampling\_id iters ...\\
										\#\#\monospace{2}1\monospace{3}sonar\monospace{2}classif.rpart
										\monospace{12}cv\monospace{4}3 ...\\
										\#\#\monospace{2}2\monospace{3}sonar classif.ranger
										\monospace{12}cv\monospace{4}3 ...\\
										\#\#\monospace{2}3\monospace{4}spam\monospace{2}classif.rpart
										\monospace{12}cv\monospace{4}3 ...\\
										\#\#\monospace{2}4\monospace{4}spam classif.ranger
										\monospace{12}cv\monospace{4}3 ...
										\vspace{1em}
										\\
										bmr\$aggregate()\\
										\#\# nr\monospace{2}resample\_result task\_id\monospace{5}learner\_id ... classif.ce\\
										\#\#\monospace{2}1 <ResampleResult>\monospace{3}sonar
										\monospace{1}classif.rpart ... 0.26928916\\
										\#\#\monospace{2}2 <ResampleResult>\monospace{3}sonar
										classif.ranger ... 0.17798482\\
										\#\#\monospace{2}3 <ResampleResult>\monospace{4}spam
										\monospace{1}classif.rpart ... 0.10106500\\
										\#\#\monospace{2}4 <ResampleResult>\monospace{4}spam
										classif.ranger ... 0.10106500}
								\end{codeboxexample}
								\vspace{0.5em}
								Results are stored as a \codeinline{data.table}.
								\codeinline{BenchmarkResult} contains a \codeinline{ResampleResult} object for each task-learner-resampling combination which in turn contain a \codeinline{Prediction} object for each resampling iteration.
							\end{myblock}
							\vfill}
					\end{minipage}
				\end{beamercolorbox}
			\end{column}
			\begin{column}{.245\textwidth}
				\begin{beamercolorbox}[center]{postercolumn}
					\begin{minipage}{.98\textwidth}
						\parbox[t][\columnheight]{\textwidth}{
							\begin{myblock}{Benchmark}
								Compare learner(s) on task(s) with resampling(s).
								\\
								\begin{codeboxmultiline}[width=19.4cm]
									design = \textbf{benchmark\_grid}(\\
									\hspace*{1ex}tasks, learners, resamplings
									)
								\end{codeboxmultiline}
								Creates a cross-join datatable with list-columns. Can also be set up manually for full control.
								\\
								\begin{codebox}
									bmr = \textbf{benchmark}(design)
								\end{codebox}
								Returns a \codeinline{\robotomono{BenckmarkResult}}
								container.
								\\
								\begin{codebox}
									bmr\$\textbf{aggregate}(measures)
								\end{codebox}
								\codeinline{data.table} of \codeinline{ResampleResult} with scores.
								\\
								\begin{codebox}
									bmr\$\textbf{score}(measures)
								\end{codebox}
								Datat\codeinline{data.table}able of resampling iterations with scores.
								\\
								\begin{codeboxmultiline}[width=26cm]
									{\footnotesize bmr\$\textbf{filter}(task\_ids, learner\_ids, resampling\_ids)}
								\end{codeboxmultiline}
								Filter by task, learner and resampling.
								\\
								\begin{codeboxmultiline}
									bmr\$\textbf{combine}(bmr)\\
									c(bmr, bmr1) \# alternative S3 method
								\end{codeboxmultiline}
								Merge other \codeinline{BenchmarkResult}.
							\end{myblock}
							\begin{myblock}{Parallelization}
								The \codeinline{future} framework is used for parallelization.
								\\
								\begin{codebox}
									future::\textbf{plan}(backend)
								\end{codebox}
								Selects the parallelization backend for the current session.
								\\
								\\
								Parallelization is automatically applied to all levels (resampling, tuning and FeatSel).
							\end{myblock}
							\begin{myblock}{Logging}
								\codeinline{lgr} is used for logging and progress output.
								\\
								\begin{codeboxmultiline}[width=23.1cm]
									\textbf{getOption}("lgr.log\_levels")\\
									\#\# fatal error  warn  info debug trace\\
									\#\# 100\monospace{3}200\monospace{3}300\monospace{2}400\monospace{2}500\monospace{3}600
								\end{codeboxmultiline}
								Gets threshold levels. The default is 400.
								\\
								\begin{codeboxmultiline}[width=25cm]
									\footnotesize{
										lgr::get\_logger("mlr3")\$\textbf{set\_threshold}("<level>")}
								\end{codeboxmultiline}
								Changes the log-level on a per-package basis.
							\end{myblock}
							\vfill}
					\end{minipage}
				\end{beamercolorbox}
			\end{column}
			\begin{column}{.245\textwidth}
				\begin{beamercolorbox}[center]{postercolumn}
					\begin{minipage}{.98\textwidth}
						\parbox[t][\columnheight]{\textwidth}{
							\begin{myblock}{mlr3viz}
								Provides visualization for \codeinline{mlr3} objects.
								Creation: \codeinline{mlr3viz::autoplot(object, type)}
								\begin{itemize}
									\item \codeinline{BenchmarkResult} (\codeinline{boxplot} of performance measures, \codeinline{roc}, \codeinline{prc})\\
									\item \codeinline{Filter} (\codeinline{barplot} of filter scores)\\
									\item \codeinline{PredictionClassif} (Stacked barplot of true and estimated class labels, \codeinline{roc}, \codeinline{prc})
									\item \codeinline{PredictionRegr} (\codeinline{xy} scatterplot, \codeinline{histogram} of residuals)
									\item \codeinline{ResampleResult} (\codeinline{boxplot} or \codeinline{histogram} of performance measures, \codeinline{roc}, \codeinline{prc})
									\item \codeinline{TaskClassif} (barplot of \codeinline{target}, duo target-features plot matrix, \codeinline{pairs} feature plot matrix with color set to target)
									\item \codeinline{TaskRegr} (\codeinline{target}, \codeinline{pairs})
									\item \codeinline{TaskSurv} (\codeinline{target}, \codeinline{duo}, \codeinline{pairs})
								\end{itemize}
							\end{myblock}
							\begin{myblock}{Error Handling and Encapsulation}
								Packages \codeinline{evaluate} and \codeinline{callr} are used internally to encapsulate execution of \codeinline{\$train()} and \codeinline{\$predict()} to prevent stops in case of errors and segfaults - useful for larger experments. \codeinline{callr} runs both steps in separate R sessions.
								\\
								\begin{codeboxmultiline}[width=20cm]
									learner\$\textbf{encapsulate} = c(\\
									\hspace*{1ex} train = "evaluate/callr", \\
									\hspace*{1ex} predict = "evaluate/callr")
								\end{codeboxmultiline}
								\vspace{1em}
								\begin{codebox}
									learner\$\textbf{errors}
								\end{codebox}
								Returns the recorded log of errors.
								\\
								\begin{codebox}
									learner\$\textbf{fallback} = lrn(.key)
								\end{codebox}
								If learner fails, a fallback learner is used to generate predictions.
								Use a robust fallback, e.g. "featureless".
							\end{myblock}
							\begin{myblock}{Resources}
								\begin{itemize}
									\item \href{https://mlr3book.mlr-org.com/index.html}{mlr3book}\\ (https://mlr3book.mlr-org.com)
									      % \item \href{https://github.com/mlr-org}{mlr-org on GitHub}\\ (https://github.com/mlr-org)
									\item \href{https://github.com/mlr-org/mlr3learners}{mlr3learners R package}\\ (https://github.com/mlr-org/mlr3learners)
									\item \href{https://github.com/mlr3learners}{mlr3learners organization}\\ (https://github.com/mlr3learners)
									\item \href{https://mlr3gallery.mlr-org.com/}{mlr3gallery use cases}\\ (https://mlr3gallery.mlr-org.com/)
								\end{itemize}
							\end{myblock}
							\vfill}
					\end{minipage}
				\end{beamercolorbox}
			\end{column}
		\end{columns}
	\end{frame}
\end{withoutheader}
\end{document}
